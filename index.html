<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, target-densitydpi=device-dpi"
    />
    <title>Lineage II Map</title>
    <link rel="shortcut icon" href="https://www.lineage2.com/images/global/favicon.png" />
    <style>
      body {
        padding: 0;
        margin: 0;
        height: 100%;
        max-height: 100%;
        overflow: hidden;
      }

      .slidecontainer {
        width: 100%;
        position: absolute;
        bottom: 15px;
      }

      .slider {
        -webkit-appearance: none;
        width: 95%;
        height: 2px;
        display: block;
        background: #d3d3d3;
        outline: none;
        margin: 10px auto;
        -webkit-transition: 0.2s;
        transition: opacity 0.2s;
      }

      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 25px;
        height: 25px;
        border-radius: 50%;
        background: #333;
        cursor: pointer;
      }

      .slider::-moz-range-thumb {
        width: 10px;
        height: 25px;
        border-radius: 5%;
        background: #333;
        cursor: pointer;
      }

      #mapcontainer {
        position: relative;
        width: 100vw;
        height: 100vh;
        padding: 0;
        margin: 0;
      }

      #map {
        width: 100vw;
      }

      .player {
        position: absolute;
        width: 5px;
        height: 5px;
        border: 2px solid red;
      }

      #pagetitle {
        position: absolute;
        top: 10px;
        left: 10px;
        color: black;
        display: block;
        font-family: -apple-system, "BlinkMacSystemFont", "Segoe UI", "Helvetica", "Arial", sans-serif,
          "Apple Color Emoji", "Segoe UI Emoji";
        text-rendering: optimizeLegibility;
      }

      .logo {
        display: block;
        background: url("./logo.png") no-repeat;
        background-size: contain;
        height: 100px;
        width: 350px;
      }
    </style>
  </head>
  <body>
    <div id="mapcontainer" class="mapcontainer">
      <span id="pagetitle">
        <div class="logo"></div>
      </span>
      <div class="slidecontainer">
        <input type="range" min="1" max="100" value="15" step="0.2" class="slider" id="slider" />
      </div>
      <canvas id="map" alt="map"></canvas>
    </div>
    <script>
      let userX = 83120,
        userY = 148600;

      const BLOCKSIZE = 32768,
        BLOCKPX = 900,
        BLOCKLIMITS = {
          X: { min: 16, max: 26, mid: 20 },
          Y: { min: 10, max: 25, mid: 18 },
        };

      const WorldToBlockNum = (n) => n / BLOCKSIZE,
        WorldToPic = (n, zoom = 1) => {
          let mod = WorldToBlockNum(n) % 1;
          if (mod < 0) mod += 1;
          return mod * BLOCKPX * zoom;
        };

      const slider = document.getElementById("slider"),
        container = document.getElementById("mapcontainer"),
        map = document.getElementById("map"),
        ctx = map.getContext("2d"),
        player = document.createElement("div");
      cachedTiles = new Array(BLOCKLIMITS.X.max + 1)
        .fill(undefined)
        .map(() => new Array(BLOCKLIMITS.Y.max + 1).fill(undefined));

      let zoom = 1;

      // Draw player
      player.className = "player";
      container.appendChild(player);

      const redraw = () => {
        if (userX > BLOCKSIZE * (BLOCKLIMITS.X.max - BLOCKLIMITS.X.mid + 1)) {
          userX = BLOCKSIZE * (BLOCKLIMITS.X.max - BLOCKLIMITS.X.mid + 1);
        }

        if (userX < BLOCKSIZE * (BLOCKLIMITS.X.min - BLOCKLIMITS.X.mid)) {
          userX = BLOCKSIZE * (BLOCKLIMITS.X.min - BLOCKLIMITS.X.mid);
        }

        if (userY > BLOCKSIZE * (BLOCKLIMITS.Y.max - BLOCKLIMITS.Y.mid + 1)) {
          userY = BLOCKSIZE * (BLOCKLIMITS.Y.max - BLOCKLIMITS.Y.mid + 1);
        }

        if (userY < BLOCKSIZE * (BLOCKLIMITS.Y.min - BLOCKLIMITS.Y.mid)) {
          userY = BLOCKSIZE * (BLOCKLIMITS.Y.min - BLOCKLIMITS.Y.mid);
        }

        console.log(userX, userY);
        // Clear canvas
        ctx.clearRect(0, 0, map.width, map.height);

        zoom = (slider.value * 10) / slider.max;
        const rect = container.getBoundingClientRect();
        map.width = rect.width;
        map.height = rect.height;

        const offsetX = WorldToPic(userX, zoom),
          offsetY = WorldToPic(userY, zoom),
          halfWidth = rect.width / 2,
          halfHeight = rect.height / 2,
          realWidth = BLOCKPX * zoom,
          realHeight = BLOCKPX * zoom,
          tileX = Math.floor(WorldToBlockNum(userX)) + BLOCKLIMITS.X.mid,
          tileY = Math.floor(WorldToBlockNum(userY)) + BLOCKLIMITS.Y.mid;

        // Position the player in the center
        player.style.top = `${halfHeight - player.style.width / 2}px`;
        player.style.left = `${halfWidth - player.style.height / 2}px`;

        // Draw the visible map grid
        for (
          let i = tileX - Math.ceil((halfWidth + offsetX) / realWidth);
          i <= tileX + Math.ceil((halfWidth - offsetX) / realWidth) + 1;
          i++
        ) {
          for (
            let j = tileY - Math.ceil((halfHeight - offsetY) / realHeight);
            j <= tileY + Math.ceil((halfHeight + offsetY) / realHeight) - 1;
            j++
          ) {
            if (i >= BLOCKLIMITS.X.min && i <= BLOCKLIMITS.X.max && j >= BLOCKLIMITS.Y.min && j <= BLOCKLIMITS.Y.max) {
              if (typeof cachedTiles[i][j] === "object" && null !== cachedTiles[i][j] && cachedTiles[i][j].complete) {
                // Tile is already in the cache (memory)
                ctx.drawImage(
                  cachedTiles[i][j],
                  halfWidth - offsetX - realWidth * (tileX - i),
                  halfHeight - offsetY - realHeight * (tileY - j),
                  realWidth,
                  realHeight
                );
              } else {
                // Load the background image
                const img = new Image();
                img.src = `./Maps/${i}_${j}.jpg`;
                img.onload = function () {
                  cachedTiles[i][j] = img;
                  ctx.drawImage(
                    cachedTiles[i][j],
                    halfWidth - offsetX - realWidth * (tileX - i),
                    halfHeight - offsetY - realHeight * (tileY - j),
                    realWidth,
                    realHeight
                  );
                };
                img.onerror = function () {
                  // cachedTiles[i][j] = null;
                  img.src = "https://dummyimage.com/900x900/ffffff/dddddd.png&text=No+map+image";
                };
              }
            }
          }
        }
      };

      window.onresize = window.onload = slider.oninput = redraw;

      map.onclick = (e) => {
        zoom = (slider.value * 10) / slider.max;
        const rect = e.target.getBoundingClientRect(),
          mouseX = e.clientX - rect.left,
          mouseY = e.clientY - rect.top,
          halfWidth = rect.width / 2,
          halfHeight = rect.height / 2;

        userX += ((mouseX - halfWidth) * (BLOCKSIZE / BLOCKPX)) / zoom;
        userY += ((mouseY - halfHeight) * (BLOCKSIZE / BLOCKPX)) / zoom;

        redraw();
      };

      function onContainerMouseWheel(event) {
        event = event ? event : window.event;
        slider.value -= event.detail ? event.detail * -1 : event.wheelDelta / 8;
        redraw();
      }

      window.addEventListener("mousewheel", onContainerMouseWheel);
      window.addEventListener("DOMMouseScroll", onContainerMouseWheel);

      let hypo = undefined;
      window.addEventListener(
        "touchmove",
        function (event) {
          let touches = event.targetTouches;
          touches = [
            { pageX: touches[0].pageX, pageY: touches[0].pageY },
            { pageX: 0, pageY: 0 },
          ];
          if (touches.length === 2) {
            let hypo1 = Math.hypot(touches[0].pageX - touches[1].pageX, touches[0].pageY - touches[1].pageY);
            if (hypo === undefined) {
              hypo = hypo1;
            }
            slider.value *= hypo1 / hypo;
          }
        },
        false
      );

      window.addEventListener(
        "touchend",
        function (event) {
          hypo = undefined;
          redraw();
        },
        false
      );
    </script>
  </body>
</html>
